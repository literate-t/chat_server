Chat Server
===========
`IOCP`를 사용한 비동기 방식의 채팅 서버입니다

## 주안점
* 성능을 크게 해치치 않는 선에서 코드 가독성에 초점을 두려고 했습니다.

* 혼자하는 작업이어도 나중에 리팩토리 등의 유지보수가 필요하며 팀 단위로 일할 때는 누군가 내 코드를 살펴볼 수 있기 때문입니다

* 변수, 함수, 클래스 등의 이름을 지을 때 의미가 최대한 드러나도록 신경 썼습니다

## 변수 명명법  
* 기본적인 규칙은 [구글의 네이밍 룰](https://google.github.io/styleguide/cppguide.html)을 참고했습니다

* 언더바
  * 프로젝트
  * 지역 변수
  * 멤버 변수(맨 뒤에 언더바 사용하여 지역 변수와 구분)

* 파스칼 케이스
  * `cpp` 파일
  * 클래스, 구조체
  * 함수
  * 상수는 `k` 접두어를 붙임

* 기타
  * 매크로와 `enum class`의 멤버는 대문자와 언더바 사용
  * 의미를 바로 알 수 있는 경우에만 약어 사용(_message->msg_)

## 기본적인 동작
* 현재는 로비가 하나만 존재하며 내부적으로 0번입니다. 서버 연결이 정상적으로 이뤄져야 로비로 입장할 수 있습니다 

* `box`에서 접속 인원을 확인할 수 있습니다. 원하는 방 번호를 직접 입력해 방에 입장합니다

* 현재는 0 ~ 4번까지의 방을 생성할 수 있습니다. 처음 접속하는 인원이 자동으로 방을 개설해 마스터가 됩니다. 같은 방에 입장한 사람끼리 대화가 가능합니다

* 정상적인 종료 방식은 방을 나가고 로비에서 나간 뒤에 `서버 연결` 버튼 옆에 있는 `종료` 버튼을 누르는 것입니다

* 방이나 로비에 머물다가 강제로 프로그램을 끄는 경우에도 서버는 정상적으로 `완료 큐`에 남아 있는 리소스를 반환하고 소켓 연결을 끊습니다. 유저의 최종 위치에 따른 리소스를 처리합니다

## 로그  
* `conmanip.h`라는 라이브러리를 사용해 경고, 디버깅 등 유형에 따라 색상을 바꿔 콘솔에 출력합니다

* 기존 라이브러리는 출력에 `cout`을 사용했지만 로깅 비용을 줄이기 위해 `printf` 함수로 변경했습니다

## 클라이언트  
* `C#`을 공부하기 위해 `C#`으로 작성했습니다. 이종 언어 간 통신을 연습해보고 싶었습니다 

* 2012년도에 게임프로그래밍 학원을 다니며 `Win32 API`를 다뤄본 적 있기 때문에 폼 작성에 어려움이 없었습니다

* `nextjs`라는 리액트 프레임워크와 `mysql`을 사용해 로그인 화면을 구현
  * 쿠키를 이용해 로그인 상태를 유지합니다
  * 로그인에 성공하면 `Logout`, `Start` 버튼이 생기며 `Start` 버튼을 누르면 채팅 프로그램을 실행합니다
  * 로그인 때 사용한 아이디가 채팅 프로그램에서의 사용자 아이디가 됩니다

## 서버
* `lock`은 `CRITICAL_SECTION`을 사용
  * 스코프를 벗어나면 자동으로 락을 해제하기 위해 표준 라이브러리의 `lock_guard`를 모방한 `Lock` 클래스를 만들었습니다
  * `Lock` 클래스 안에 `LockGuard` 클래스를 둬서 객체 생성만으로 락이 걸리고 객체가 소멸되면서 락이 해제되게끔 했습니다

* 입출력하는 횟수를 저장하는 변수는 `C++` 문법인 `atomic`을 활용 
  * 어셈블리에서 해당 구문에 직접 `lock`이 걸리기 때문에 성능의 이점이 있습니다

* 패킷 전송은 유저, 로비, 패킷 매니저 클래스가 담당
  * 함수 객체를 `function` 라이브러리를 이용해 생성하고 `Main`에서 패킷 전송 함수를 람다함수로 감싼 뒤 필요한 클래스에 전달합니다

* 패킷 매니저 클래스에 패킷을 처리하는 함수를 정의
  * 패킷 아이디로 함수를 호출하기 위해 아이디를 `key`로, 함수 포인터를 `value `로 설정했습니다

* `Main` 클래스에서 인스턴스를 만들 때, 안전하게 포인터 변수 관리하기 위해 `unique_ptr`을 사용

* `Message` 구조체
  *  `worker thread`로 수신한 데이터는 `message completion port`로 보내는데, 타입과 데이터를 `Message` 구조체에 담습니다 
  *  `Message` 객체는 필요할 때마다 생성하지 않고 `MessagePool`에서 할당받는 구조입니다. 
  *  멀티스레드 환경이므로 공유 자원 접근 문제가 발생합니다
  *  문법에서 지원하는 기능을 쓰는 것이 성능에 이점이 있어 `MessagePool` 클래스는 `concurrent_queue<Message*>`로 선언된 멤버 변수를 가지고 있습니다

* 조건문을 검사할 때 상수 값을 먼저 작성
  * `==` 연산자를 쓰지 않고 실수로 `=` 연산자를 쓰는 일이 없도록 했습니다
  * 이런 실수는 찾기 어렵기 때문에 예방이 중요하다 생각합니다

* `C++17` Structured binding
  * `std::tuple`를 통해 값을 반환하거나, `foreach` 반복문을 돌릴 때 가독성에 도움되며 코드 길이를 줄일 수 있습니다

* `const`
  * 함수의 파라미터와 `get`함수에는 될 수 있으면 `const`를 붙였습니다
  * `stl`에서 연산자가 `const` 지원하지 않는 등의 부득이한 사유가 있을 땐 사용하지 못했습니다

* `copy elison`
  * 클라이언트 요청에 대한 응답 패킷을 만들 때 함수를 이용하며 `RVO`를 위해 임시 객체를 만들어 반환합니다
  * 성능이 떨어지지 않으면서 어떤 작업을 위한 코드인지 비교적 쉽게 파악할 수 있습니다
