Chat Server
===========
**IOCP**를 사용한 비동기 방식의 채팅 서버입니다.

## 변수 명명법  
* 멤버 변수는 **파스칼 케이스**, 지역 변수(매개 변수 포함)은 **카멜 케이스**를 사용했습니다.  

* 상수는 구글에서 만든 Naming Rule을 참고해 k 접두어로 시작하는 **파스칼 케이스**을 적용했습니다.  

* 매크로와 enum class의 멤버는 언더바를 이용해 의미를 구분했습니다. 전부 대문자입니다. 

* 약어 사용을 최소화했습니다. 변수 이름에서 역할과 기능을 잘 보여주는 것에 주안점을 뒀습니다. 변수 이름이 너무 길어지거나 클래스 이름이 변수 이름에 가장 적합하다고 생각될 경우에 약어를 사용했습니다.

## 로그  
* `conmanip.h`라는 라이브러리를 사용해 경고, 디버깅 등 유형에 따라 색상을 바꿔 콘솔에 출력합니다. 기존 라이브러리는 출력에 `cout`을 사용했지만 로깅에 들어가는 자원 소모를 줄이기 위해 `printf` 함수로 변경했습니다.  

* 헤더파일에 함수 구현부까지 있기 때문에 `stdafx.h`에 `conmainip.h`로 로그 기능을 구현한 `Logger` 클래스를 넣으면 오브젝트 파일이 링크되는 과정에서 오류가 발생했습니다. 이를 해결하기 위해 `ILog` 클래스를 만들어 `Logger` 클래스가 상속하게 하고 `stdafx.h`에는 `ILog` 클래스를 넣었습니다. `Main` 클래스에서 유일한 `Logger` 객체를 만들고 이를 다른 객체의 `init` 함수의 매개변수로 전달해 사용하게 했습니다.

## 클라이언트  
* C#으로 작성했습니다. **다른 언어끼리 통신하는 것**을 연습할 필요성을 느꼈고 `C#`을 경험해보고 싶었습니다.
WinAPI를 다뤄본 적 있기 때문에 폼 작성에 큰 어려움은 없었습니다. 네트워킹과 스레드 사용에서 C#의 강력함을 느낄 수 있었습니다.  

* 데이터를 byte 단위로 변환하거나 수신한 byte[] 데이터에서 원하는 위치에 원하는 만큼 데이터를 추출하는 함수가 지원되는 점이 편했습니다.

## 서버
* STL의 엄격한 타입 체크를 경험했습니다. UserIdDic은 unordered_map으로 선언한 변수며 키가 const char* 이었고 밸류가 User* 입니다.
FindUser 함수에서 id를 인자로 받아 UserIdDic.find(id)을 통해 반복자를 얻어야 하는데, id를 string으로 넣으니 작동하지 않았습니다.  
* `lock`은 `CRITICAL_SECTION`을 사용했습니다. 락을 해제할 때 일일이 `unlock` 하는 불편함을 줄이기 위해 표준 라이브러리의 `lock_guard`를 모방한 `Lock` 클래스를 만들었습니다. `Lock` 클래스 안에 `LockGuard` 클래스를 둬서 객체 생성만으로 락이 걸리고 객체가 소멸되면서 락이 해제되게끔 했습니다. 입출력하는 횟수를 저장하는 변수는 `Inter` 계열의 함수가 아닌 C++ 문법인 `atomic`을 활용했습니다. 어셈블리에서 해당 구문에 직접 lock이 걸리기 때문에 속도가 빠르기 때문입니다. 
* 패킷 전송은 유저, 로비, 패킷 매니저 클래스가 담당하는데 함수 객체를 `function` 라이브러리를 이용해 생성하고 `Main`에서 패킷 전송 함수를 람다함수로 감싼 뒤 필요한 클래스에 전달합니다. 
* 패킷 매니저 클래스에 패킷을 처리하는 함수가 정의되어 있습니다. 패킷 아이디로 함수를 호출하기 위해 아이디를 `key`로, 함수 포인터를 `value `로 설정했습니다. 
* `Main` 클래스에서 클래스들의 인스턴스를 만드는데, 안전하게 포인터 변수를  사용하기 위해 unique_ptr을 사용했습니다.  
* `Message`라는 구조체가 있습니다. `Wokrer thread`로 수신한 데이터는 `Logic completion port`로 보내는데, 타입과 데이터를 `Message` 구조체에 담습니다. `Message` 객체는 필요할 때마다 생성하지 않고 `MessagePool`에서 할당받는 구조입니다. 멀티스레드 환경이므로 **공유자원 접근 문제**가 발생합니다. 락을 걸어도 되지만, 문법에서 지원하는 기능을 쓰는 것이 성능에 이점이 있어 `MessagePool` 클래스는 `concurrent_queue< Message* >`로 선언된 멤버 변수를 가지고 있습니다.
